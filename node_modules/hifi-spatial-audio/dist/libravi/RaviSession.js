var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { RaviStreamController } from './RaviStreamController';
import { RaviUtils } from './RaviUtils';
import { RaviCommandController } from './RaviCommandController';
;
export var RaviSessionStates;
(function (RaviSessionStates) {
    RaviSessionStates["NEW"] = "new";
    RaviSessionStates["CONNECTING"] = "checking";
    RaviSessionStates["CONNECTED"] = "connected";
    RaviSessionStates["COMPLETED"] = "completed";
    RaviSessionStates["DISCONNECTED"] = "disconnected";
    RaviSessionStates["FAILED"] = "failed";
    RaviSessionStates["CLOSED"] = "closed";
})(RaviSessionStates || (RaviSessionStates = {}));
;
export class RaviSession {
    constructor() {
        RaviUtils.log("Constructor", "RaviSession");
        this._stateChangeHandlers = new Set();
        this._uuid = RaviUtils.createUUID();
        this._commandController = new RaviCommandController();
        this._streamController = new RaviStreamController(this._commandController);
        this._state = RaviSessionStates.CLOSED;
        this._raviImplementation = new RaviWebRTCImplementation(this);
        const raviImpl = this._raviImplementation;
        this._streamController.setInputAudioChangeHandler(raviImpl._addAudioInputStream.bind(raviImpl));
        this._streamController.setInputVideoChangeHandler(raviImpl._addVideoInputStream.bind(raviImpl));
    }
    getState() {
        return this._state;
    }
    getUUID() {
        return this._uuid;
    }
    addStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.add(changeHandler);
            return true;
        }
        catch (err) {
            RaviUtils.err("Error adding a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    removeStateChangeHandler(changeHandler) {
        try {
            this._stateChangeHandlers.delete(changeHandler);
            return true;
        }
        catch (err) {
            RaviUtils.err("Error removing a state change handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    getCommandController() {
        return this._commandController;
    }
    getStreamController() {
        return this._streamController;
    }
    openRAVISession(count, { signalingConnection, timeout = 5000, params = null }) {
        console.log("_______________________________openRAVISession ", count);
        var raviSession = this;
        this._raviImplementation._assignSignalingConnection(signalingConnection);
        return new Promise((resolve, reject) => {
            RaviUtils.log("Opening RAVI session", "RaviSession");
            if (count < 2) {
                reject(Error("NOPE."));
            }
            let timer = setTimeout(() => {
                RaviUtils.log("RaviSession.open timed out after " + timeout + " ms", "RaviSession");
                reject(Error("RaviSession.open timed out"));
                raviSession.closeRAVISession();
            }, timeout);
            const stateHandler = function (event) {
                var state = "";
                if (event && event.state)
                    state = event.state;
                if (state === RaviSessionStates.NEW ||
                    state === RaviSessionStates.CONNECTING ||
                    state === RaviSessionStates.DISCONNECTED) {
                    RaviUtils.log("RAVI session state is " + state, "RaviSession");
                }
                else if (state === RaviSessionStates.CONNECTED ||
                    state === RaviSessionStates.COMPLETED) {
                    clearHandlerAndTimeout();
                    resolve(state);
                }
                else if (state === RaviSessionStates.FAILED) {
                    clearHandlerAndTimeout();
                    const closeTimer = setTimeout(() => {
                        raviSession._raviImplementation._close();
                    }, 0);
                    reject(Error(state));
                }
                else if (state === RaviSessionStates.CLOSED) {
                    clearHandlerAndTimeout();
                    reject(Error(state));
                }
            };
            const clearHandlerAndTimeout = function () {
                raviSession.removeStateChangeHandler(stateHandler);
                if (timer) {
                    clearTimeout(timer);
                    timer = null;
                }
            };
            raviSession.addStateChangeHandler(stateHandler);
            raviSession._raviImplementation._open(params);
        });
    }
    closeRAVISession() {
        var raviSession = this;
        this._streamController._stop();
        this._commandController.stopMonitoringQueues();
        return new Promise((resolve, reject) => {
            RaviUtils.log("Closing RAVI session", "RaviSession");
            const stateHandler = function (event) {
                var state = "";
                if (event && event.state)
                    state = event.state;
                if (state === RaviSessionStates.DISCONNECTED) {
                    RaviUtils.log("Closing...", "RaviSession");
                }
                else if (state === RaviSessionStates.CLOSED) {
                    raviSession.removeStateChangeHandler(stateHandler);
                    resolve(state);
                }
                else {
                    raviSession.removeStateChangeHandler(stateHandler);
                    reject(Error(state));
                }
            };
            raviSession.addStateChangeHandler(stateHandler);
            var event = { "state": RaviSessionStates.DISCONNECTED };
            raviSession._handleStateChange(event, RaviSessionStates.DISCONNECTED);
            raviSession._raviImplementation._close();
        });
    }
    _doOntrack(event) {
        RaviUtils.log("Received new track: ", "RaviSession");
        RaviUtils.log(event, "RaviSession");
        if (event && event.track && event.track.kind === "video") {
            RaviUtils.log("Adding remote video track to stream controller", "RaviSession");
            this._streamController._setVideoStream(event.streams[0]);
            this._streamController._onVideoStreamStateChanged("ready");
        }
        if (event && event.track && event.track.kind === "audio") {
            RaviUtils.log("Adding remote audio track to stream controller", "RaviSession");
            this._streamController._setAudioStream(event.streams[0]);
        }
    }
    _doOndatachannel(event) {
        RaviUtils.log("Received new channel: ", "RaviSession");
        RaviUtils.log(event, "RaviSession");
        switch (event.channel.label) {
            case "ravi.input":
                this._commandController._setInputDataChannel(event.channel);
                break;
            case "ravi.command":
                this._commandController._setCommandDataChannel(event.channel);
                break;
            default:
                RaviUtils.log("Received unknown data channel named " + event.channel.label, "RaviSession");
                break;
        }
    }
    _handleStateChange(event, state) {
        this._state = state;
        if (!event) {
            return;
        }
        event["state"] = state;
        RaviUtils.log("_handleStateChange: " + JSON.stringify(event), "RaviSession");
        this._stateChangeHandlers.forEach(function (handler) {
            if (handler) {
                handler(event);
            }
        });
    }
    addStatsObserver(observer) {
        return this._raviImplementation._addStatsObserver(observer);
    }
    removeStatsObserver(observer) {
        return this._raviImplementation._removeStatsObserver(observer);
    }
}
const STATS_WATCHER_FILTER = new Map([
    ["remote-inbound-rtp", ["id", "type", "timestamp", "roundTripTime", "jitter"]],
    ["inbound-rtp", ["id", "type", "timestamp", "jitterBufferDelay", "jitterBufferEmittedCount", "bytesReceived"]]
]);
class RaviWebRTCStatsWatcher {
    constructor(webRTCImplementation) {
        RaviUtils.log("constructor", "RaviStatsWatcher");
        this._raviImplementation = webRTCImplementation;
        this._observers = new Set();
        this._filter = STATS_WATCHER_FILTER;
        this._interval = 0;
        this._prevStats = [];
    }
    stop() {
        if (this._interval) {
            window.clearInterval(this._interval);
            this._interval = 0;
        }
    }
    addObserver(observer) {
        try {
            this._observers.add(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            RaviUtils.err("Error adding a stats observer: " +
                err.message, "RaviStatsWatcher");
            return false;
        }
        return false;
    }
    removeObserver(observer) {
        try {
            this._observers.delete(observer);
            this._onObserverChange();
            return true;
        }
        catch (err) {
            RaviUtils.err("Error removing a stats observer handler: " +
                err.message, "RaviSession");
            return false;
        }
        return false;
    }
    _onObserverChange() {
        const INTERVAL = 1000;
        this._prevStats = [];
        if (this._observers.size > 0) {
            if (!this._interval) {
                window.setInterval((handler, timeout) => __awaiter(this, void 0, void 0, function* () {
                    const stats = yield this._raviImplementation._getStats();
                    let filteredStats = [];
                    if (stats) {
                        stats.forEach((report) => {
                            if (this._filter.has(report.type)) {
                                let selectedFields = this._filter.get(report.type);
                                let filteredReport = {};
                                selectedFields.forEach(key => {
                                    filteredReport[key] = report[key];
                                });
                                filteredStats.push(filteredReport);
                            }
                        });
                    }
                    if (filteredStats.length) {
                        this._observers.forEach((observer) => {
                            observer(filteredStats, this._prevStats);
                        });
                    }
                    this._prevStats = filteredStats;
                }), INTERVAL);
            }
        }
        else {
            if (this._interval) {
                window.clearInterval(this._interval);
                this._interval = 0;
            }
        }
    }
}
let crossPlatformRTCPeerConnection = null;
let crossPlatformRTCSessionDescription = null;
if (typeof self === 'undefined') {
    crossPlatformRTCPeerConnection = require('wrtc').RTCPeerConnection;
    crossPlatformRTCSessionDescription = require('wrtc').RTCSessionDescription;
}
else {
    crossPlatformRTCPeerConnection = RTCPeerConnection;
    crossPlatformRTCSessionDescription = RTCSessionDescription;
}
const peerConnectionConfig = {
    'iceServers': [
        { 'urls': 'stun:stun.l.google.com:19302' },
        { 'urls': 'turn:turn.highfidelity.com:3478',
            'username': 'clouduser',
            'credential': 'chariot-travesty-hook'
        }
    ]
};
class RaviWebRTCImplementation {
    constructor(raviSession) {
        RaviUtils.log("constructor", "RaviWebRTCImplementation");
        this._raviSession = raviSession;
        this._negotiator = this._setupConnection.bind(this);
        this._initRtcConnection();
        this._statsWatcher = new RaviWebRTCStatsWatcher(this);
    }
    _initRtcConnection() {
        const raviSession = this._raviSession;
        const that = this;
        this._rtcConnection = new crossPlatformRTCPeerConnection(peerConnectionConfig);
        const rtcConnection = this._rtcConnection;
        let senders = rtcConnection.getSenders();
        senders.forEach((sender) => {
            sender.replaceTrack(null);
        });
        this._raviAudioSenders = [];
        this._raviVideoSenders = [];
        rtcConnection.addEventListener('iceconnectionstatechange', function (event) {
            raviSession._handleStateChange(event, rtcConnection.iceConnectionState);
        });
        rtcConnection.addEventListener('datachannel', function (event) { raviSession._doOndatachannel(event); });
        rtcConnection.addEventListener('track', function (event) { raviSession._doOntrack(event); });
        rtcConnection.addEventListener('icecandidate', function (event) { that._doOnicecandidate(event); });
        rtcConnection.addEventListener('negotiationneeded', function (event) { that._doOnnegotiationneeded(event); });
        rtcConnection.addEventListener("signalingstatechange", function (event) { that._doOnsignalingstatechanged(event); });
    }
    _assignSignalingConnection(signalingConnection) {
        this._signalingConnection = signalingConnection;
    }
    _addAudioInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const that = this;
        var retval = false;
        if (stream) {
            const currentSenders = this._raviAudioSenders;
            const newAudioTracks = stream.getAudioTracks();
            const numNewTracks = newAudioTracks.length;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                if (i < numNewTracks) {
                    RaviUtils.log("Replacing audio track #" + i + "  in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(newAudioTracks[i]);
                }
                else {
                    RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                    currentSenders[i].replaceTrack(null);
                }
            }
            for (i; i < numNewTracks; i++) {
                RaviUtils.log("Adding local audio track #" + i + " to rtcConnection", "RaviWebRTCImplementation");
                currentSenders.push(rtcConnection.addTrack(newAudioTracks[i], stream));
            }
        }
        else {
            const currentSenders = this._raviAudioSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                RaviUtils.log("Setting audio sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _addVideoInputStream(stream) {
        const rtcConnection = this._rtcConnection;
        const that = this;
        var retval = false;
        if (stream) {
            const currentSenders = this._raviVideoSenders;
            const newVideoTracks = stream.getVideoTracks();
            const numNewTracks = newVideoTracks.length;
            if (numNewTracks > 0) {
                if (currentSenders.length > 0) {
                    RaviUtils.log("Replacing video track #0 in rtcConnection", "RaviWebRTCImplementation");
                    currentSenders[0].replaceTrack(newVideoTracks[0]);
                }
                else {
                    RaviUtils.log("Adding video track #0 to rtcConnection", "RaviWebRTCImplementation");
                    currentSenders.push(rtcConnection.addTrack(newVideoTracks[0]));
                }
                retval = true;
            }
            else {
                RaviUtils.log("Assigned video stream doesn't contain vidoe track", "RaviWebRTCImplementation");
            }
        }
        else {
            const currentSenders = this._raviVideoSenders;
            let i = 0;
            for (i; i < currentSenders.length; i++) {
                RaviUtils.log("Setting video sender #" + i + " to null", "RaviWebRTCImplementation");
                currentSenders[i].replaceTrack(null);
            }
        }
        return retval;
    }
    _open(params) {
        RaviUtils.log("Attempting to open connection...", "RaviWebRTCImplementation");
        if (this._rtcConnection.connectionState == 'connecting' || this._rtcConnection.connectionState == 'connected') {
            RaviUtils.log("We already have a connection in progress. Will not attempt a new one.", "RaviWebRTCImplementation");
            this._raviSession._handleStateChange({ "state": this._rtcConnection.connectionState }, this._rtcConnection.connectionState);
            return;
        }
        if (this._signalingConnection) {
            this._signalingConnection.addMessageHandler(this._negotiator);
            let message = {};
            if (params) {
                message = params;
                message["sessionID"] = this._raviSession.getUUID();
            }
            else {
                message = this._raviSession.getUUID();
            }
            this._signalingConnection.send(JSON.stringify({ 'request': message }));
        }
    }
    _close() {
        if (this._rtcConnection) {
            this._statsWatcher.stop();
            RaviUtils.log("closing", "RaviWebRTCImplementation");
            this._rtcConnection.close();
            this._rtcConnection = null;
            var event = { "state": RaviSessionStates.CLOSED };
            this._raviSession._handleStateChange(event, RaviSessionStates.CLOSED);
            this._signalingConnection.removeMessageHandler(this._negotiator);
            this._initRtcConnection();
        }
    }
    _doOnicecandidate(event) {
        if (event.candidate && event.candidate != "") {
            RaviUtils.log("Sending local ICE candidate: " + JSON.stringify(event.candidate), "RaviWebRTCImplementation");
            this._signalingConnection.send(JSON.stringify({ 'ice': event.candidate, 'uuid': this._raviSession.getUUID() }));
        }
        else {
            RaviUtils.log("End of local ICE candidates", "RaviSession");
        }
    }
    _doOnnegotiationneeded(event) {
        RaviUtils.log("need renegotiation please", "RaviWebRTCImplementation");
        const msg = {
            renegotiate: "please",
            uuid: this._raviSession.getUUID()
        };
        const desc = JSON.stringify(msg);
        if (this._signalingConnection && this._rtcConnection.signalingState === "stable") {
            this._signalingConnection.send(desc);
        }
    }
    _doOnsignalingstatechanged(event) {
        RaviUtils.log("SignalingState changed: " + this._rtcConnection.signalingState, "RaviWebRTCImplementation");
    }
    _forceBitrateUp(sdp) {
        const localAudioIsStereo = this._raviSession._streamController.isStereoInput();
        const bitrate = localAudioIsStereo ? 128000 : 64000;
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=' + bitrate + ';');
    }
    _forceStereoDown(sdp) {
        return sdp.replace(/a=fmtp:111 /g, 'a=fmtp:111 maxaveragebitrate=128000;sprop-stereo=1;stereo=1;');
    }
    _setupConnection(event) {
        let fullMessage = "";
        let signal = "";
        const raviSession = this._raviSession;
        const rtcConnection = this._rtcConnection;
        const signalingConnection = this._signalingConnection;
        const that = this;
        if (!raviSession || !rtcConnection || !signalingConnection) {
            RaviUtils.err("Missing one of raviSession, rtcConnection, or signalingConnection! Can't set up connection.", "RaviWebRTCImplementation");
            return;
        }
        if (event && event.data) {
            RaviUtils.log('Message from server: ' + event.data, "RaviWebRTCImplementation");
            fullMessage = JSON.parse(event.data);
        }
        else {
            RaviUtils.log('No message received by onMessage handler', "RaviWebRTCImplementation");
            return;
        }
        signal = fullMessage[raviSession.getUUID()];
        if (!signal)
            return;
        if (signal.sdp) {
            RaviUtils.log("Got sdp of type:" + signal.type, "RaviWebRTCImplementation");
            signal.sdp = that._forceBitrateUp(signal.sdp);
            const desc = new crossPlatformRTCSessionDescription(signal);
            rtcConnection.setRemoteDescription(desc)
                .then(function () {
                return rtcConnection.createAnswer();
            })
                .then(function (answer) {
                answer.sdp = that._forceStereoDown(answer.sdp);
                RaviUtils.log("Answer:", "RaviWebRTCImplementation");
                RaviUtils.log(answer, "RaviWebRTCImplementation");
                return rtcConnection.setLocalDescription(answer);
            })
                .then(function () {
                const msg = {
                    type: "answer",
                    sdp: rtcConnection.localDescription,
                    uuid: raviSession.getUUID()
                };
                const desc = JSON.stringify(msg);
                RaviUtils.log("Sending answer to server", "RaviWebRTCImplementation");
                signalingConnection.send(desc);
            });
        }
        else if (signal.ice) {
            RaviUtils.log("Received remote ICE candidate: " + JSON.stringify(signal.ice), "RaviWebRTCImplementation");
            rtcConnection.addIceCandidate(signal.ice)
                .then(function () {
                RaviUtils.log("Added remote candidate", "RaviWebRTCImplementation");
            })
                .catch(function (e) {
                RaviUtils.err("Error attempting to add remote ICE candidate: " + e.message, "RaviWebRTCImplementation");
            });
        }
        else {
            RaviUtils.log("Unknown message " + JSON.stringify(signal), "RaviWebRTCImplementation");
        }
    }
    _addStatsObserver(observer) {
        return this._statsWatcher.addObserver(observer);
    }
    _removeStatsObserver(observer) {
        return this._statsWatcher.removeObserver(observer);
    }
    _getStats(selector = null) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._rtcConnection) {
                return this._rtcConnection.getStats(selector);
            }
            else {
                return {};
            }
        });
    }
}
//# sourceMappingURL=RaviSession.js.map