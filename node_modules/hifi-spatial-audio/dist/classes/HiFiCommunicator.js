var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { HiFiConstants } from "../constants/HiFiConstants";
import { HiFiLogger } from "../utilities/HiFiLogger";
import { HiFiUtilities } from "../utilities/HiFiUtilities";
import { HiFiAudioAPIData, ReceivedHiFiAudioAPIData, Point3D, OrientationQuat3D, OrientationEuler3D, eulerToQuaternion, eulerFromQuaternion } from "./HiFiAudioAPIData";
import { HiFiAxisUtilities, ourHiFiAxisConfiguration } from "./HiFiAxisConfiguration";
import { HiFiMixerSession } from "./HiFiMixerSession";
import { AvailableUserDataSubscriptionComponents } from "./HiFiUserDataSubscription";
export var HiFiConnectionStates;
(function (HiFiConnectionStates) {
    HiFiConnectionStates["Connected"] = "Connected";
    HiFiConnectionStates["Disconnected"] = "Disconnected";
    HiFiConnectionStates["Failed"] = "Failed";
    HiFiConnectionStates["Unavailable"] = "Unavailable";
})(HiFiConnectionStates || (HiFiConnectionStates = {}));
;
export var HiFiUserDataStreamingScopes;
(function (HiFiUserDataStreamingScopes) {
    HiFiUserDataStreamingScopes["None"] = "none";
    HiFiUserDataStreamingScopes["Peers"] = "peers";
    HiFiUserDataStreamingScopes["All"] = "all";
})(HiFiUserDataStreamingScopes || (HiFiUserDataStreamingScopes = {}));
;
export class HiFiCommunicator {
    constructor({ initialHiFiAudioAPIData = new HiFiAudioAPIData(), onConnectionStateChanged, onUsersDisconnected, transmitRateLimitTimeoutMS = HiFiConstants.DEFAULT_TRANSMIT_RATE_LIMIT_TIMEOUT_MS, userDataStreamingScope = HiFiUserDataStreamingScopes.All, hiFiAxisConfiguration, webrtcSessionParams } = {}) {
        this._timers = {
            transmitRateLimitTimeout: null,
            wantedToTransmitHiFiAudioAPIData: true
        };
        if (transmitRateLimitTimeoutMS < HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS) {
            HiFiLogger.warn(`\`transmitRateLimitTimeoutMS\` must be >= ${HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms! Setting to ${HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS}ms...`);
            transmitRateLimitTimeoutMS = HiFiConstants.MIN_TRANSMIT_RATE_LIMIT_TIMEOUT_MS;
        }
        this.transmitRateLimitTimeoutMS = transmitRateLimitTimeoutMS;
        if (onUsersDisconnected) {
            this.onUsersDisconnected = onUsersDisconnected;
        }
        this._mixerSession = new HiFiMixerSession({
            "userDataStreamingScope": userDataStreamingScope,
            "onUserDataUpdated": (data) => { this._handleUserDataUpdates(data); },
            "onUsersDisconnected": (data) => { this._onUsersDisconnected(data); },
            "onConnectionStateChanged": onConnectionStateChanged
        });
        this._inputAudioMediaStream = undefined;
        this._currentHiFiAudioAPIData = new HiFiAudioAPIData();
        this._lastTransmittedHiFiAudioAPIData = new HiFiAudioAPIData();
        this._userDataSubscriptions = [];
        if (webrtcSessionParams && webrtcSessionParams.audioMinJitterBufferDuration && (webrtcSessionParams.audioMinJitterBufferDuration < 0.0 || webrtcSessionParams.audioMinJitterBufferDuration > 10.0)) {
            HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMinJitterBufferDuration\` (${webrtcSessionParams.audioMinJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMinJitterBufferDuration = HiFiUtilities.clamp(webrtcSessionParams.audioMinJitterBufferDuration, 0.0, 10.0);
        }
        if (webrtcSessionParams && webrtcSessionParams.audioMaxJitterBufferDuration && (webrtcSessionParams.audioMaxJitterBufferDuration < 0.0 || webrtcSessionParams.audioMaxJitterBufferDuration > 10.0)) {
            HiFiLogger.warn(`The value of \`webrtcSessionParams.audioMaxJitterBufferDuration\` (${webrtcSessionParams.audioMaxJitterBufferDuration}) will be clamped to (0.0, 10.0).`);
            webrtcSessionParams.audioMaxJitterBufferDuration = HiFiUtilities.clamp(webrtcSessionParams.audioMaxJitterBufferDuration, 0.0, 10.0);
        }
        this._webRTCSessionParams = webrtcSessionParams;
        if (hiFiAxisConfiguration) {
            if (HiFiAxisUtilities.verify(hiFiAxisConfiguration)) {
                ourHiFiAxisConfiguration.rightAxis = hiFiAxisConfiguration.rightAxis;
                ourHiFiAxisConfiguration.leftAxis = hiFiAxisConfiguration.leftAxis;
                ourHiFiAxisConfiguration.intoScreenAxis = hiFiAxisConfiguration.intoScreenAxis;
                ourHiFiAxisConfiguration.outOfScreenAxis = hiFiAxisConfiguration.outOfScreenAxis;
                ourHiFiAxisConfiguration.upAxis = hiFiAxisConfiguration.upAxis;
                ourHiFiAxisConfiguration.downAxis = hiFiAxisConfiguration.downAxis;
                ourHiFiAxisConfiguration.handedness = hiFiAxisConfiguration.handedness;
                ourHiFiAxisConfiguration.eulerOrder = hiFiAxisConfiguration.eulerOrder;
            }
            else {
                HiFiLogger.error(`There is an error with the passed \`HiFiAxisConfiguration\`, so the new axis configuration was not set. There are more error details in the logs above.`);
            }
        }
        this._updateUserData(initialHiFiAudioAPIData);
    }
    connectToHiFiAudioAPIServer(count, hifiAuthJWT, signalingHostURL, signalingPort) {
        console.log("_______________________________connectToHiFiAudioAPIServer ", count);
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                let errMsg = `\`this._mixerSession\` is falsey!`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            let mixerConnectionResponse;
            let signalingHostURLSafe;
            try {
                signalingHostURLSafe = new URL(signalingHostURL).hostname;
            }
            catch (e) {
                signalingHostURLSafe = signalingHostURL ? signalingHostURL : HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_ENDPOINT;
            }
            signalingPort = signalingPort ? signalingPort : HiFiConstants.DEFAULT_PROD_HIGH_FIDELITY_PORT;
            try {
                let webRTCSignalingAddress = `wss://${signalingHostURLSafe}:${signalingPort}/?token=`;
                this._mixerSession.webRTCAddress = `${webRTCSignalingAddress}${hifiAuthJWT}`;
                HiFiLogger.log(`Using WebRTC Signaling Address:\n${webRTCSignalingAddress}<token redacted>`);
                mixerConnectionResponse = yield this._mixerSession.connectToHiFiMixer(count, { webRTCSessionParams: this._webRTCSessionParams });
            }
            catch (errorConnectingToMixer) {
                let errMsg = `Error when connecting to mixer! Error:\n${errorConnectingToMixer}`;
                return Promise.reject({
                    success: false,
                    error: errMsg
                });
            }
            this._transmitHiFiAudioAPIDataToServer(true);
            return Promise.resolve({
                success: true,
                audionetInitResponse: mixerConnectionResponse.audionetInitResponse
            });
        });
    }
    setOtherUserGainForThisConnection(visitIdHash, gain) {
        return __awaiter(this, void 0, void 0, function* () {
            let otherUserGainMap = {};
            otherUserGainMap[visitIdHash] = gain;
            let result = this.setOtherUserGainsForThisConnection(otherUserGainMap);
            return Promise.resolve(result);
        });
    }
    setOtherUserGainsForThisConnection(otherUserGainMap) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.assign(this._currentHiFiAudioAPIData._otherUserGainQueue, otherUserGainMap);
            let result = this._transmitHiFiAudioAPIDataToServer();
            return Promise.resolve({
                success: result.success,
                error: result.error
            });
        });
    }
    disconnectFromHiFiAudioAPIServer() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._mixerSession) {
                return Promise.resolve(`No mixer session from which we can disconnect!`);
            }
            this._inputAudioMediaStream = undefined;
            this.onUsersDisconnected = undefined;
            this._userDataSubscriptions = [];
            this._currentHiFiAudioAPIData = undefined;
            this._lastTransmittedHiFiAudioAPIData = new HiFiAudioAPIData();
            return this._mixerSession.disconnectFromHiFiMixer();
        });
    }
    getOutputAudioMediaStream() {
        if (this._mixerSession) {
            return this._mixerSession.getOutputAudioMediaStream();
        }
        else {
            return null;
        }
    }
    setInputAudioMediaStream(newInputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const retval = yield this._mixerSession.setRAVIInputAudio(newInputAudioMediaStream, isStereo);
            if (retval) {
                this._inputAudioMediaStream = newInputAudioMediaStream;
            }
            else {
                HiFiLogger.warn(`Error trying to setRAVIInputAudio on this._mixerSession`);
            }
            return retval;
        });
    }
    setInputAudioMuted(isMuted) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._mixerSession) {
                HiFiLogger.debug(`Setting mute state to : ${isMuted}`);
                return yield this._mixerSession.setInputAudioMuted(isMuted);
            }
            else {
                HiFiLogger.warn(`Couldn't set mute state: No \`_mixerSession\`.`);
                return false;
            }
        });
    }
    getCommunicatorInfo() {
        let retval = {
            "clientInfo": {
                "inputAudioStreamSet": !!this._inputAudioMediaStream,
            }
        };
        let isBrowserContext = typeof self !== 'undefined';
        if (isBrowserContext && typeof (HIFI_API_VERSION) === "string") {
            retval.clientInfo["apiVersion"] = HIFI_API_VERSION;
        }
        if (this._mixerSession && this._mixerSession.mixerInfo) {
            retval["serverInfo"] = this._mixerSession.mixerInfo;
        }
        return retval;
    }
    startCollectingWebRTCStats(callback) {
        if (!this._mixerSession) {
            HiFiLogger.error(`Couldn't start collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.startCollectingWebRTCStats(callback);
    }
    stopCollectingWebRTCStats() {
        if (!this._mixerSession) {
            HiFiLogger.error(`Couldn't stop collecting WebRTC Stats: No \`_mixerSession\`!`);
        }
        this._mixerSession.stopCollectingWebRTCStats();
    }
    _updateUserData({ position, orientationQuat, orientationEuler, volumeThreshold, hiFiGain, userAttenuation, userRolloff } = {}) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (position) {
            if (!this._currentHiFiAudioAPIData.position) {
                this._currentHiFiAudioAPIData.position = new Point3D();
            }
            this._currentHiFiAudioAPIData.position.x = (_a = position.x) !== null && _a !== void 0 ? _a : this._currentHiFiAudioAPIData.position.x;
            this._currentHiFiAudioAPIData.position.y = (_b = position.y) !== null && _b !== void 0 ? _b : this._currentHiFiAudioAPIData.position.y;
            this._currentHiFiAudioAPIData.position.z = (_c = position.z) !== null && _c !== void 0 ? _c : this._currentHiFiAudioAPIData.position.z;
        }
        if (orientationQuat) {
            if (!this._currentHiFiAudioAPIData.orientationQuat) {
                this._currentHiFiAudioAPIData.orientationQuat = new OrientationQuat3D();
            }
            this._currentHiFiAudioAPIData.orientationQuat.w = (_d = orientationQuat.w) !== null && _d !== void 0 ? _d : this._currentHiFiAudioAPIData.orientationQuat.w;
            this._currentHiFiAudioAPIData.orientationQuat.x = (_e = orientationQuat.x) !== null && _e !== void 0 ? _e : this._currentHiFiAudioAPIData.orientationQuat.x;
            this._currentHiFiAudioAPIData.orientationQuat.y = (_f = orientationQuat.y) !== null && _f !== void 0 ? _f : this._currentHiFiAudioAPIData.orientationQuat.y;
            this._currentHiFiAudioAPIData.orientationQuat.z = (_g = orientationQuat.z) !== null && _g !== void 0 ? _g : this._currentHiFiAudioAPIData.orientationQuat.z;
        }
        else if (orientationEuler) {
            let checkedEuler = new OrientationEuler3D(orientationEuler);
            this._currentHiFiAudioAPIData.orientationQuat = eulerToQuaternion(checkedEuler, ourHiFiAxisConfiguration.eulerOrder);
        }
        if (typeof (volumeThreshold) === "number") {
            this._currentHiFiAudioAPIData.volumeThreshold = volumeThreshold;
        }
        if (typeof (hiFiGain) === "number") {
            this._currentHiFiAudioAPIData.hiFiGain = Math.max(0, hiFiGain);
        }
        if (typeof (userAttenuation) === "number") {
            this._currentHiFiAudioAPIData.userAttenuation = userAttenuation;
        }
        if (typeof (userRolloff) === "number") {
            this._currentHiFiAudioAPIData.userRolloff = Math.max(0, userRolloff);
        }
    }
    _maybeClearRateLimitTimeout() {
        if (this._timers.transmitRateLimitTimeout) {
            clearTimeout(this._timers.transmitRateLimitTimeout);
        }
        this._timers.transmitRateLimitTimeout = null;
    }
    _updateLastTransmittedHiFiAudioAPIData(dataJustTransmitted) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (dataJustTransmitted.position) {
            if (!this._lastTransmittedHiFiAudioAPIData.position) {
                this._lastTransmittedHiFiAudioAPIData.position = new Point3D();
            }
            this._lastTransmittedHiFiAudioAPIData.position.x = (_a = dataJustTransmitted.position.x) !== null && _a !== void 0 ? _a : this._lastTransmittedHiFiAudioAPIData.position.x;
            this._lastTransmittedHiFiAudioAPIData.position.y = (_b = dataJustTransmitted.position.y) !== null && _b !== void 0 ? _b : this._lastTransmittedHiFiAudioAPIData.position.y;
            this._lastTransmittedHiFiAudioAPIData.position.z = (_c = dataJustTransmitted.position.z) !== null && _c !== void 0 ? _c : this._lastTransmittedHiFiAudioAPIData.position.z;
        }
        if (dataJustTransmitted.orientationQuat) {
            if (!this._lastTransmittedHiFiAudioAPIData.orientationQuat) {
                this._lastTransmittedHiFiAudioAPIData.orientationQuat = new OrientationQuat3D();
            }
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.w = (_d = dataJustTransmitted.orientationQuat.w) !== null && _d !== void 0 ? _d : this._lastTransmittedHiFiAudioAPIData.orientationQuat.w;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.x = (_e = dataJustTransmitted.orientationQuat.x) !== null && _e !== void 0 ? _e : this._lastTransmittedHiFiAudioAPIData.orientationQuat.x;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.y = (_f = dataJustTransmitted.orientationQuat.y) !== null && _f !== void 0 ? _f : this._lastTransmittedHiFiAudioAPIData.orientationQuat.y;
            this._lastTransmittedHiFiAudioAPIData.orientationQuat.z = (_g = dataJustTransmitted.orientationQuat.z) !== null && _g !== void 0 ? _g : this._lastTransmittedHiFiAudioAPIData.orientationQuat.z;
        }
        if (typeof (dataJustTransmitted.volumeThreshold) === "number") {
            this._lastTransmittedHiFiAudioAPIData["volumeThreshold"] = dataJustTransmitted.volumeThreshold;
        }
        if (typeof (dataJustTransmitted.hiFiGain) === "number") {
            this._lastTransmittedHiFiAudioAPIData["hiFiGain"] = dataJustTransmitted.hiFiGain;
        }
        if (typeof (dataJustTransmitted.userAttenuation) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userAttenuation"] = dataJustTransmitted.userAttenuation;
        }
        if (typeof (dataJustTransmitted.userRolloff) === "number") {
            this._lastTransmittedHiFiAudioAPIData["userRolloff"] = dataJustTransmitted.userRolloff;
        }
        if (typeof (dataJustTransmitted._otherUserGainQueue) === "object") {
            if (typeof (this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue) !== "object") {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            }
            for (const idToGain of Object.entries(dataJustTransmitted._otherUserGainQueue)) {
                this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue[idToGain[0]] = idToGain[1];
            }
        }
    }
    _transmitHiFiAudioAPIDataToServer(forceTransmit) {
        if (this._mixerSession && (!this._timers.transmitRateLimitTimeout || forceTransmit)) {
            this._timers.wantedToTransmitHiFiAudioAPIData = false;
            this._maybeClearRateLimitTimeout();
            if (!forceTransmit) {
                this._timers.transmitRateLimitTimeout = setTimeout(() => {
                    this._maybeClearRateLimitTimeout();
                    if (this._timers.wantedToTransmitHiFiAudioAPIData) {
                        this._transmitHiFiAudioAPIDataToServer(true);
                    }
                }, this.transmitRateLimitTimeoutMS);
            }
            let transmitRetval = this._mixerSession._transmitHiFiAudioAPIDataToServer(this._currentHiFiAudioAPIData, this._lastTransmittedHiFiAudioAPIData);
            if (transmitRetval.success) {
                this._updateLastTransmittedHiFiAudioAPIData(this._currentHiFiAudioAPIData);
                this._cleanUpHiFiAudioAPIDataHistory();
                return {
                    success: true,
                    rawDataTransmitted: transmitRetval.stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: transmitRetval.error
                };
            }
        }
        else if (this._mixerSession && this._timers.transmitRateLimitTimeout && !forceTransmit) {
            this._timers.wantedToTransmitHiFiAudioAPIData = true;
            return {
                success: true,
                error: `Transfer is rate limited. Transfer will occur shortly automatically.`
            };
        }
        else if (!this._mixerSession) {
            return {
                success: false,
                error: `No server connection yet; can't transmit user data.`
            };
        }
    }
    _cleanUpHiFiAudioAPIDataHistory() {
        this._currentHiFiAudioAPIData._otherUserGainQueue = {};
        let maxCachedOtherUserGains = 1000;
        if (Object.keys(this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue).length > maxCachedOtherUserGains) {
            this._lastTransmittedHiFiAudioAPIData._otherUserGainQueue = {};
            HiFiLogger.warn(`Stored \`_lastTransmittedHiFiAudioAPIData._otherUserGainQueue\` was too large and was cleared to save space.`);
        }
    }
    updateUserDataAndTransmit(newUserData) {
        this._updateUserData(newUserData);
        return this._transmitHiFiAudioAPIDataToServer();
    }
    _handleUserDataUpdates(newUserDataFromServer) {
        if (this._userDataSubscriptions.length === 0) {
            return;
        }
        for (let subItr = 0; subItr < this._userDataSubscriptions.length; subItr++) {
            let currentSubscription = this._userDataSubscriptions[subItr];
            if (!currentSubscription.callback) {
                continue;
            }
            let currentSubscriptionCallbackData = [];
            for (let dataItr = 0; dataItr < newUserDataFromServer.length; dataItr++) {
                let currentDataFromServer = newUserDataFromServer[dataItr];
                if (currentSubscription.providedUserID && currentDataFromServer.providedUserID !== currentSubscription.providedUserID) {
                    continue;
                }
                let newCallbackData = new ReceivedHiFiAudioAPIData();
                if (typeof (currentDataFromServer.providedUserID) === "string") {
                    newCallbackData.providedUserID = currentDataFromServer.providedUserID;
                }
                if (typeof (currentDataFromServer.hashedVisitID) === "string") {
                    newCallbackData.hashedVisitID = currentDataFromServer.hashedVisitID;
                }
                let shouldPushNewCallbackData = false;
                for (let componentItr = 0; componentItr < currentSubscription.components.length; componentItr++) {
                    let currentComponent = currentSubscription.components[componentItr];
                    switch (currentComponent) {
                        case AvailableUserDataSubscriptionComponents.Position:
                            if (currentDataFromServer.position) {
                                newCallbackData.position = currentDataFromServer.position;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case AvailableUserDataSubscriptionComponents.OrientationQuat:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationQuat = currentDataFromServer.orientationQuat;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case AvailableUserDataSubscriptionComponents.OrientationEuler:
                            if (currentDataFromServer.orientationQuat) {
                                newCallbackData.orientationEuler = eulerFromQuaternion(currentDataFromServer.orientationQuat, ourHiFiAxisConfiguration.eulerOrder);
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case AvailableUserDataSubscriptionComponents.VolumeDecibels:
                            if (typeof (currentDataFromServer.volumeDecibels) === "number") {
                                newCallbackData.volumeDecibels = currentDataFromServer.volumeDecibels;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case AvailableUserDataSubscriptionComponents.HiFiGain:
                            if (typeof (currentDataFromServer.hiFiGain) === "number") {
                                newCallbackData.hiFiGain = currentDataFromServer.hiFiGain;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                        case AvailableUserDataSubscriptionComponents.IsStereo:
                            if (typeof (currentDataFromServer.isStereo) === "boolean") {
                                newCallbackData.isStereo = currentDataFromServer.isStereo;
                                shouldPushNewCallbackData = true;
                            }
                            break;
                    }
                }
                if (shouldPushNewCallbackData) {
                    currentSubscriptionCallbackData.push(newCallbackData);
                }
            }
            if (currentSubscription.callback && currentSubscriptionCallbackData.length > 0) {
                currentSubscription.callback(currentSubscriptionCallbackData);
            }
        }
    }
    _onUsersDisconnected(usersDisconnected) {
        if (this.onUsersDisconnected) {
            this.onUsersDisconnected(usersDisconnected);
        }
    }
    addUserDataSubscription(newSubscription) {
        if (!this._mixerSession) {
            HiFiLogger.error(`No \`_mixerSession\`! Data subscription not added.`);
            return;
        }
        if (this._mixerSession.userDataStreamingScope === HiFiUserDataStreamingScopes.None) {
            HiFiLogger.error(`During \`HiFiCommunicator\` construction, the server was set up to **not** send user data! Data subscription not added.`);
            return;
        }
        HiFiLogger.log(`Adding new User Data Subscription:\n${JSON.stringify(newSubscription)}`);
        this._userDataSubscriptions.push(newSubscription);
    }
}
//# sourceMappingURL=HiFiCommunicator.js.map