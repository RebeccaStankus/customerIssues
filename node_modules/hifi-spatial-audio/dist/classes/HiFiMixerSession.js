var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { OrientationQuat3D, Point3D, ReceivedHiFiAudioAPIData } from "./HiFiAudioAPIData";
import { HiFiLogger } from "../utilities/HiFiLogger";
import { HiFiConnectionStates, HiFiUserDataStreamingScopes } from "./HiFiCommunicator";
import { RaviUtils } from "../libravi/RaviUtils";
import { RaviSession, RaviSessionStates } from "../libravi/RaviSession";
import { RaviSignalingConnection, RaviSignalingStates } from "../libravi/RaviSignalingConnection";
import { HiFiAxisUtilities, ourHiFiAxisConfiguration } from "./HiFiAxisConfiguration";
const pako = require('pako');
const INIT_TIMEOUT_MS = 5000;
const PERSONAL_VOLUME_ADJUST_TIMEOUT_MS = 5000;
export class HiFiMixerSession {
    constructor({ userDataStreamingScope = HiFiUserDataStreamingScopes.All, onUserDataUpdated, onUsersDisconnected, onConnectionStateChanged }) {
        this.webRTCAddress = undefined;
        this.userDataStreamingScope = userDataStreamingScope;
        this.onUserDataUpdated = onUserDataUpdated;
        this.onUsersDisconnected = onUsersDisconnected;
        this._mixerPeerKeyToStateCacheDict = {};
        RaviUtils.setDebug(false);
        this._raviSignalingConnection = new RaviSignalingConnection();
        this._raviSignalingConnection.addStateChangeHandler((event) => {
            this.onRAVISignalingStateChanged(event);
        });
        this._raviSession = new RaviSession();
        this._raviSession.addStateChangeHandler((event) => {
            this.onRAVISessionStateChanged(event);
        });
        this.onConnectionStateChanged = onConnectionStateChanged;
        this._resetMixerInfo();
    }
    promiseToRunAudioInit() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                let initData = {
                    primary: true,
                    visit_id: this._raviSession.getUUID(),
                    session: this._raviSession.getUUID(),
                    streaming_scope: this.userDataStreamingScope,
                    is_input_stream_stereo: this._inputAudioMediaStreamIsStereo
                };
                let commandController = this._raviSession.getCommandController();
                if (!commandController) {
                    return Promise.reject({
                        success: false,
                        error: `Couldn't connect to mixer: no \`commandController\`!`
                    });
                }
                let initTimeout = setTimeout(() => {
                    this.disconnectFromHiFiMixer();
                    return Promise.reject({
                        success: false,
                        error: `Couldn't connect to mixer: Call to \`init\` timed out!`
                    });
                }, INIT_TIMEOUT_MS);
                commandController.queueCommand("audionet.init", initData, (response) => __awaiter(this, void 0, void 0, function* () {
                    clearTimeout(initTimeout);
                    let parsedResponse;
                    try {
                        parsedResponse = JSON.parse(response);
                        this.mixerInfo["connected"] = true;
                        this.mixerInfo["build_number"] = parsedResponse.build_number;
                        this.mixerInfo["build_type"] = parsedResponse.build_type;
                        this.mixerInfo["build_version"] = parsedResponse.build_version;
                        this.mixerInfo["visit_id_hash"] = parsedResponse.visit_id_hash;
                        resolve({
                            success: true,
                            audionetInitResponse: parsedResponse
                        });
                    }
                    catch (e) {
                        reject({
                            success: false,
                            error: `Couldn't parse init response! Parse error:\n${e}`
                        });
                    }
                }));
            });
        });
    }
    handleRAVISessionBinaryData(data) {
        let unGZippedData = pako.ungzip(data, { to: 'string' });
        let jsonData = JSON.parse(unGZippedData);
        if (jsonData.deleted_visit_ids) {
            let allDeletedUserData = [];
            let deletedVisitIDs = jsonData.deleted_visit_ids;
            for (const deletedVisitID of deletedVisitIDs) {
                let hashedVisitID = deletedVisitID;
                let deletedUserData = new ReceivedHiFiAudioAPIData({
                    hashedVisitID: hashedVisitID
                });
                let mixerPeerKeys = Object.keys(this._mixerPeerKeyToStateCacheDict);
                for (const mixerPeerKey of mixerPeerKeys) {
                    if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].hashedVisitID === hashedVisitID) {
                        if (this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID) {
                            deletedUserData.providedUserID = this._mixerPeerKeyToStateCacheDict[mixerPeerKey].providedUserID;
                        }
                        break;
                    }
                }
                allDeletedUserData.push(deletedUserData);
            }
            if (this.onUsersDisconnected && allDeletedUserData.length > 0) {
                this.onUsersDisconnected(allDeletedUserData);
            }
        }
        if (jsonData.peers) {
            let allNewUserData = [];
            let peerKeys = Object.keys(jsonData.peers);
            for (let itr = 0; itr < peerKeys.length; itr++) {
                let peerDataFromMixer = jsonData.peers[peerKeys[itr]];
                let userDataCache;
                if (this._mixerPeerKeyToStateCacheDict[peerKeys[itr]]) {
                    userDataCache = this._mixerPeerKeyToStateCacheDict[peerKeys[itr]];
                }
                else {
                    userDataCache = new ReceivedHiFiAudioAPIData();
                    this._mixerPeerKeyToStateCacheDict[peerKeys[itr]] = userDataCache;
                }
                let newUserData = new ReceivedHiFiAudioAPIData();
                if (userDataCache.providedUserID) {
                    newUserData.providedUserID = userDataCache.providedUserID;
                }
                else if (typeof (peerDataFromMixer.J) === "string") {
                    userDataCache.providedUserID = peerDataFromMixer.J;
                    newUserData.providedUserID = peerDataFromMixer.J;
                }
                if (userDataCache.hashedVisitID) {
                    newUserData.hashedVisitID = userDataCache.hashedVisitID;
                }
                else if (typeof (peerDataFromMixer.e) === "string") {
                    userDataCache.hashedVisitID = peerDataFromMixer.e;
                    newUserData.hashedVisitID = peerDataFromMixer.e;
                }
                let serverSentNewUserData = false;
                let serverSentNewPosition = false;
                if (typeof (peerDataFromMixer.x) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new Point3D();
                    }
                    userDataCache.position.x = peerDataFromMixer.x / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.y) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new Point3D();
                    }
                    userDataCache.position.y = peerDataFromMixer.y / 1000;
                    serverSentNewPosition = true;
                }
                if (typeof (peerDataFromMixer.z) === "number") {
                    if (!userDataCache.position) {
                        userDataCache.position = new Point3D();
                    }
                    userDataCache.position.z = peerDataFromMixer.z / 1000;
                    serverSentNewPosition = true;
                }
                if (serverSentNewPosition) {
                    newUserData.position = HiFiAxisUtilities.translatePoint3DFromMixerSpace(ourHiFiAxisConfiguration, userDataCache.position);
                    serverSentNewUserData = true;
                }
                let serverSentNewOrientation = false;
                if (typeof (peerDataFromMixer.W) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.w = peerDataFromMixer.W / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.X) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.x = peerDataFromMixer.X / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Y) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.y = peerDataFromMixer.Y / 1000;
                    serverSentNewOrientation = true;
                }
                if (typeof (peerDataFromMixer.Z) === "number") {
                    if (!userDataCache.orientationQuat) {
                        userDataCache.orientationQuat = new OrientationQuat3D();
                    }
                    userDataCache.orientationQuat.z = peerDataFromMixer.Z / 1000;
                    serverSentNewOrientation = true;
                }
                if (serverSentNewOrientation) {
                    newUserData.orientationQuat = HiFiAxisUtilities.translateOrientationQuat3DFromMixerSpace(ourHiFiAxisConfiguration, userDataCache.orientationQuat);
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.g) === "number") {
                    userDataCache.hiFiGain = peerDataFromMixer.g;
                    newUserData.hiFiGain = peerDataFromMixer.g;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.v) === "number") {
                    userDataCache.volumeDecibels = peerDataFromMixer.v;
                    newUserData.volumeDecibels = peerDataFromMixer.v;
                    serverSentNewUserData = true;
                }
                if (typeof (peerDataFromMixer.s) === "boolean") {
                    userDataCache.isStereo = peerDataFromMixer.s;
                    newUserData.isStereo = peerDataFromMixer.s;
                    serverSentNewUserData = true;
                }
                if (serverSentNewUserData) {
                    allNewUserData.push(newUserData);
                }
            }
            if (this.onUserDataUpdated && allNewUserData.length > 0) {
                this.onUserDataUpdated(allNewUserData);
            }
        }
    }
    connectToHiFiMixer(count, { webRTCSessionParams }) {
        console.log("_______________________________connectToHiFiMixer ", count);
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.webRTCAddress) {
                let errMsg = `Couldn't connect: \`this.webRTCAddress\` is falsey!`;
                this.disconnectFromHiFiMixer();
                return Promise.reject(errMsg);
            }
            console.log("_______________________________ made it past 228");
            this._currentHiFiConnectionState = undefined;
            let mixerIsUnavailable = false;
            const tempUnavailableStateHandler = (event) => {
                if (event && event.state === RaviSignalingStates.UNAVAILABLE) {
                    mixerIsUnavailable = true;
                    this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                    this._raviSession.closeRAVISession();
                }
            };
            this._raviSignalingConnection.addStateChangeHandler(tempUnavailableStateHandler);
            try {
                yield this._raviSignalingConnection.openRAVISignalingConnection(this.webRTCAddress);
            }
            catch (errorOpeningSignalingConnection) {
                console.log("_______________________________ catch");
                let errMsg = `Couldn't open signaling connection to \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningSignalingConnection}`;
                this.disconnectFromHiFiMixer();
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            console.log("_______________________________ made it past 252");
            try {
                yield this._raviSession.openRAVISession(count, { signalingConnection: this._raviSignalingConnection, params: webRTCSessionParams });
            }
            catch (errorOpeningRAVISession) {
                let errMsg = `Couldn't open RAVI session associated with \`${this.webRTCAddress.slice(0, this.webRTCAddress.indexOf("token="))}<token redacted>\`! Error:\n${errorOpeningRAVISession}`;
                if (mixerIsUnavailable) {
                    errMsg = `High Fidelity server is at capacity; service is unavailable.`;
                }
                this.disconnectFromHiFiMixer();
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            console.log("_______________________________ made it past 265");
            let audionetInitResponse;
            try {
                audionetInitResponse = yield this.promiseToRunAudioInit();
            }
            catch (initError) {
                let errMsg = `\`audionet.init\` command failed! Error:\n${initError.error}`;
                this.disconnectFromHiFiMixer();
                this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
                return Promise.reject(errMsg);
            }
            console.log("_______________________________ made it past 276");
            this._raviSignalingConnection.removeStateChangeHandler(tempUnavailableStateHandler);
            this._raviSession.getCommandController().addBinaryHandler((data) => { this.handleRAVISessionBinaryData(data); }, true);
            return Promise.resolve(audionetInitResponse);
        });
    }
    disconnectFromHiFiMixer() {
        return __awaiter(this, void 0, void 0, function* () {
            function close(thingToClose, nameOfThingToClose, closedState) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (thingToClose) {
                        let state = thingToClose.getState();
                        if (!thingToClose || state === closedState) {
                            HiFiLogger.log(`The RAVI ${nameOfThingToClose} was already closed.`);
                        }
                        else {
                            try {
                                if (thingToClose instanceof RaviSignalingConnection) {
                                    yield thingToClose.closeRAVISignalingConnection();
                                }
                                else if (thingToClose instanceof RaviSession) {
                                    yield thingToClose.closeRAVISession();
                                }
                                HiFiLogger.log(`The RAVI ${nameOfThingToClose} closed successfully from state ${state}.`);
                            }
                            catch (e) {
                                HiFiLogger.warn(`The RAVI ${nameOfThingToClose} didn't close successfully from state ${state}! Error:\n${e}`);
                            }
                        }
                    }
                    else {
                        HiFiLogger.warn(`The RAVI ${nameOfThingToClose} was missing.`);
                    }
                    thingToClose = null;
                });
            }
            yield close(this._raviSignalingConnection, "Signaling Connection", RaviSignalingStates.CLOSED);
            yield close(this._raviSession, "Session", RaviSessionStates.CLOSED);
            this._resetMixerInfo();
            return Promise.resolve(`Successfully disconnected.`);
        });
    }
    setRAVIInputAudio(inputAudioMediaStream, isStereo = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let retval = false;
            if (this._raviSession) {
                let streamController = this._raviSession.getStreamController();
                if (!streamController) {
                    HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`streamController\`!`);
                    retval = false;
                }
                else {
                    streamController.setInputAudio(inputAudioMediaStream, isStereo);
                    HiFiLogger.log(`Successfully set input audio on _raviSession.streamController!`);
                    retval = true;
                }
            }
            else {
                HiFiLogger.warn(`Couldn't set input audio on _raviSession.streamController: No \`_raviSession\`!`);
                retval = false;
            }
            if (retval) {
                if (this._inputAudioMediaStreamIsStereo != isStereo) {
                    if (this._raviSession.getState() === RaviSessionStates.CONNECTED) {
                        HiFiLogger.warn(`Stereo status has changed from ${this._inputAudioMediaStreamIsStereo} to ${isStereo}; attempting to re-initialize with the mixer`);
                        let audionetInitResponse;
                        try {
                            this._inputAudioMediaStreamIsStereo = isStereo;
                            audionetInitResponse = yield this.promiseToRunAudioInit();
                        }
                        catch (initError) {
                            let errMsg = `Attempt to call \`audionet.init\` for change in stereo status failed! Error:\n${initError.error}`;
                            return Promise.reject(errMsg);
                        }
                    }
                    else {
                        this._inputAudioMediaStreamIsStereo = isStereo;
                    }
                }
            }
            return retval;
        });
    }
    setInputAudioMuted(newMutedValue, tryToStopMicStream = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let streamController = this._raviSession.getStreamController();
            if (this._raviSession && streamController) {
                let hasMicPermission = false;
                if (navigator.permissions && navigator.permissions.query) {
                    let result;
                    try {
                        result = yield navigator.permissions.query({ name: 'microphone' });
                    }
                    catch (_a) { }
                    if (result && result.state === "granted") {
                        hasMicPermission = true;
                    }
                }
                if (!tryToStopMicStream || !hasMicPermission || typeof self === 'undefined') {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = !newMutedValue;
                        });
                        HiFiLogger.log(`Successfully set mute state to ${newMutedValue} on _raviSession.streamController._inputAudioStream`);
                        return true;
                    }
                    else {
                        HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
                else {
                    let raviAudioStream = streamController._inputAudioStream;
                    if (raviAudioStream && newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            this._cachedMediaTrackConstraints = track.getConstraints();
                            track.stop();
                        });
                        streamController.setInputAudio(null);
                        HiFiLogger.log(`Successfully set mute state to \`true\` by stopping all input media tracks!`);
                        return true;
                    }
                    else if (!raviAudioStream && !newMutedValue) {
                        let newMediaStream = yield navigator.mediaDevices.getUserMedia({ audio: this._cachedMediaTrackConstraints, video: false });
                        streamController.setInputAudio(newMediaStream);
                        HiFiLogger.log(`Successfully set mute state to \`false\` by getting new input media stream!`);
                        return true;
                    }
                    else if (raviAudioStream && !newMutedValue) {
                        raviAudioStream.getTracks().forEach((track) => {
                            track.enabled = true;
                        });
                        HiFiLogger.log(`Successfully set mute state to \`false\` by enabling all tracks on \`_raviSession.streamController._inputAudioStream\`!`);
                        return true;
                    }
                    else {
                        HiFiLogger.warn(`Couldn't set mute state: No \`_inputAudioStream\` on \`_raviSession.streamController\`.`);
                    }
                }
            }
            else {
                HiFiLogger.warn(`Couldn't set mute state: No \`_raviSession\`, or \`_raviSession.getStreamController()\` returned null.`);
                return false;
            }
        });
    }
    getOutputAudioMediaStream() {
        if (!this._raviSession) {
            return null;
        }
        let streamController = this._raviSession.getStreamController();
        if (!streamController) {
            return null;
        }
        return streamController.getAudioStream();
    }
    _setCurrentHiFiConnectionState(state) {
        if (this._currentHiFiConnectionState !== state) {
            this._currentHiFiConnectionState = state;
            if (this.onConnectionStateChanged) {
                this.onConnectionStateChanged(this._currentHiFiConnectionState);
            }
        }
    }
    onRAVISignalingStateChanged(event) {
        HiFiLogger.log(`New RAVI signaling state: \`${event.state}\``);
        switch (event.state) {
            case RaviSignalingStates.UNAVAILABLE:
                this._setCurrentHiFiConnectionState(HiFiConnectionStates.Unavailable);
                this.disconnectFromHiFiMixer();
                break;
        }
    }
    onRAVISessionStateChanged(event) {
        HiFiLogger.log(`New RAVI session state: \`${event.state}\``);
        switch (event.state) {
            case RaviSessionStates.CONNECTED:
                this._mixerPeerKeyToStateCacheDict = {};
                this._setCurrentHiFiConnectionState(HiFiConnectionStates.Connected);
                break;
            case RaviSessionStates.DISCONNECTED:
                if (this._currentHiFiConnectionState === HiFiConnectionStates.Unavailable) {
                    break;
                }
                this._setCurrentHiFiConnectionState(HiFiConnectionStates.Disconnected);
                this.disconnectFromHiFiMixer();
                break;
            case RaviSessionStates.FAILED:
                if (this._currentHiFiConnectionState === HiFiConnectionStates.Unavailable) {
                    break;
                }
                this._setCurrentHiFiConnectionState(HiFiConnectionStates.Failed);
                break;
        }
    }
    startCollectingWebRTCStats(callback) {
        if (!this._raviSession) {
            HiFiLogger.error(`Couldn't start collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        if (this._statsObserverCallback) {
            this.stopCollectingWebRTCStats();
        }
        this._statsObserverCallback = callback;
        this._raviSession.addStatsObserver(this._statsObserverCallback);
    }
    stopCollectingWebRTCStats() {
        if (!this._raviSession) {
            HiFiLogger.error(`Couldn't stop collecting WebRTC stats: No \`_raviSession\`!`);
            return;
        }
        this._raviSession.removeStatsObserver(this._statsObserverCallback);
        this._statsObserverCallback = undefined;
    }
    _transmitHiFiAudioAPIDataToServer(currentHifiAudioAPIData, previousHifiAudioAPIData) {
        if (!this.mixerInfo["connected"] || !this._raviSession) {
            return {
                success: false,
                error: `Can't transmit data to mixer; not connected to mixer.`
            };
        }
        let dataForMixer = {};
        if (currentHifiAudioAPIData.position && (typeof (currentHifiAudioAPIData.position.x) === "number")
            && (typeof (currentHifiAudioAPIData.position.y) === "number")
            && (typeof (currentHifiAudioAPIData.position.z) === "number")) {
            let changedComponents = { x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.position) {
                if (currentHifiAudioAPIData.position.x !== previousHifiAudioAPIData.position.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.y !== previousHifiAudioAPIData.position.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.position.z !== previousHifiAudioAPIData.position.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedPosition = HiFiAxisUtilities.translatePoint3DToMixerSpace(ourHiFiAxisConfiguration, currentHifiAudioAPIData.position);
                if (changedComponents.x) {
                    dataForMixer["x"] = Math.round(translatedPosition.x * 1000);
                }
                if (changedComponents.y) {
                    dataForMixer["y"] = Math.round(translatedPosition.y * 1000);
                }
                if (changedComponents.z) {
                    dataForMixer["z"] = Math.round(translatedPosition.z * 1000);
                }
            }
        }
        if (currentHifiAudioAPIData.orientationQuat && (typeof (currentHifiAudioAPIData.orientationQuat.w) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.x) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.y) === "number")
            && (typeof (currentHifiAudioAPIData.orientationQuat.z) === "number")) {
            let changedComponents = { w: false, x: false, y: false, z: false, changed: false };
            if (previousHifiAudioAPIData && previousHifiAudioAPIData.orientationQuat) {
                if (currentHifiAudioAPIData.orientationQuat.w !== previousHifiAudioAPIData.orientationQuat.w) {
                    changedComponents.w = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.x !== previousHifiAudioAPIData.orientationQuat.x) {
                    changedComponents.x = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.y !== previousHifiAudioAPIData.orientationQuat.y) {
                    changedComponents.y = true;
                    changedComponents.changed = true;
                }
                if (currentHifiAudioAPIData.orientationQuat.z !== previousHifiAudioAPIData.orientationQuat.z) {
                    changedComponents.z = true;
                    changedComponents.changed = true;
                }
            }
            else {
                changedComponents.w = true;
                changedComponents.x = true;
                changedComponents.y = true;
                changedComponents.z = true;
                changedComponents.changed = true;
            }
            if (changedComponents.changed) {
                let translatedOrientation = HiFiAxisUtilities.translateOrientationQuat3DToMixerSpace(ourHiFiAxisConfiguration, currentHifiAudioAPIData.orientationQuat);
                if (changedComponents.w) {
                    dataForMixer["W"] = translatedOrientation.w * 1000;
                }
                if (changedComponents.x) {
                    dataForMixer["X"] = translatedOrientation.x * 1000;
                }
                if (changedComponents.y) {
                    dataForMixer["Y"] = translatedOrientation.y * 1000;
                }
                dataForMixer["Z"] = translatedOrientation.z * 1000;
            }
        }
        if (typeof (currentHifiAudioAPIData.volumeThreshold) === "number") {
            dataForMixer["T"] = currentHifiAudioAPIData.volumeThreshold;
        }
        if (typeof (currentHifiAudioAPIData.hiFiGain) === "number") {
            dataForMixer["g"] = Math.max(0, currentHifiAudioAPIData.hiFiGain);
        }
        if (typeof (currentHifiAudioAPIData.userAttenuation) === "number") {
            dataForMixer["a"] = currentHifiAudioAPIData.userAttenuation;
        }
        if (typeof (currentHifiAudioAPIData.userRolloff) === "number") {
            dataForMixer["r"] = Math.max(0, currentHifiAudioAPIData.userRolloff);
        }
        if (typeof (currentHifiAudioAPIData._otherUserGainQueue) == "object") {
            let changedUserGains = {};
            let idToGains = Object.entries(currentHifiAudioAPIData._otherUserGainQueue);
            let previousOtherUserGains = previousHifiAudioAPIData ? previousHifiAudioAPIData._otherUserGainQueue : undefined;
            for (const idToGain of idToGains) {
                let hashedVisitId = idToGain[0];
                let gain = idToGain[1];
                if (!(typeof (gain) == "number")) {
                    continue;
                }
                if (previousOtherUserGains && previousOtherUserGains[hashedVisitId] === gain) {
                    continue;
                }
                changedUserGains[hashedVisitId] = gain;
            }
            if (Object.entries(changedUserGains).length) {
                dataForMixer["V"] = changedUserGains;
            }
        }
        if (Object.keys(dataForMixer).length === 0) {
            return {
                success: true,
                stringifiedDataForMixer: JSON.stringify({})
            };
        }
        else {
            let commandController = this._raviSession.getCommandController();
            if (commandController) {
                let stringifiedDataForMixer = JSON.stringify(dataForMixer);
                commandController.sendInput(stringifiedDataForMixer);
                return {
                    success: true,
                    stringifiedDataForMixer: stringifiedDataForMixer
                };
            }
            else {
                return {
                    success: false,
                    error: `Can't transmit data to mixer; no \`commandController\`!.`
                };
            }
        }
    }
    _resetMixerInfo() {
        this.mixerInfo = {
            "connected": false,
        };
    }
}
//# sourceMappingURL=HiFiMixerSession.js.map