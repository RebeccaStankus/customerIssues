import { HiFiUtilities } from "../utilities/HiFiUtilities";
export class Point3D {
    constructor({ x = 0, y = 0, z = 0 } = {}) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
export class OrientationQuat3D {
    constructor({ w = 1, x = 0, y = 0, z = 0 } = {}) {
        this.w = HiFiUtilities.clampNonan(w, -1, 1, 1);
        this.x = HiFiUtilities.clampNonan(x, -1, 1, 0);
        this.y = HiFiUtilities.clampNonan(y, -1, 1, 0);
        this.z = HiFiUtilities.clampNonan(z, -1, 1, 0);
    }
}
function sanitizeAngleDegrees(v) {
    if (isNaN(v) || v === Infinity) {
        return 0;
    }
    else if (v === -Infinity) {
        return -0;
    }
    else {
        return v % 360;
    }
}
export class OrientationEuler3D {
    constructor({ pitchDegrees = 0, yawDegrees = 0, rollDegrees = 0 } = {}) {
        this.pitchDegrees = sanitizeAngleDegrees(pitchDegrees);
        this.yawDegrees = sanitizeAngleDegrees(yawDegrees);
        this.rollDegrees = sanitizeAngleDegrees(rollDegrees);
    }
}
export var OrientationEuler3DOrder;
(function (OrientationEuler3DOrder) {
    OrientationEuler3DOrder["PitchYawRoll"] = "PitchYawRoll";
    OrientationEuler3DOrder["YawPitchRoll"] = "YawPitchRoll";
    OrientationEuler3DOrder["RollPitchYaw"] = "RollPitchYaw";
    OrientationEuler3DOrder["RollYawPitch"] = "RollYawPitch";
    OrientationEuler3DOrder["YawRollPitch"] = "YawRollPitch";
    OrientationEuler3DOrder["PitchRollYaw"] = "PitchRollYaw";
})(OrientationEuler3DOrder || (OrientationEuler3DOrder = {}));
export function eulerToQuaternion(euler, order) {
    const HALF_DEG_TO_RAD = 0.5 * Math.PI / 180.0;
    let cos = { P: Math.cos(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.cos(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.cos(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let sin = { P: Math.sin(euler.pitchDegrees * HALF_DEG_TO_RAD), Y: Math.sin(euler.yawDegrees * HALF_DEG_TO_RAD), R: Math.sin(euler.rollDegrees * HALF_DEG_TO_RAD) };
    let ax = sin.P * cos.Y * cos.R;
    let ay = cos.P * sin.Y * cos.R;
    let az = cos.P * cos.Y * sin.R;
    let aw = cos.P * cos.Y * cos.R;
    let bx = cos.P * sin.Y * sin.R;
    let by = sin.P * cos.Y * sin.R;
    let bz = sin.P * sin.Y * cos.R;
    let bw = sin.P * sin.Y * sin.R;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay - by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az + bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw + bw,
                });
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                return new OrientationQuat3D({
                    x: ax + bx,
                    y: ay + by,
                    z: az - bz,
                    w: aw - bw,
                });
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                return new OrientationQuat3D({
                    x: ax - bx,
                    y: ay - by,
                    z: az + bz,
                    w: aw + bw,
                });
            }
            break;
    }
}
export function eulerFromQuaternion(quat, order) {
    let qx2 = quat.x * quat.x;
    let qy2 = quat.y * quat.y;
    let qz2 = quat.z * quat.z;
    let qwx = quat.w * quat.x;
    let qwy = quat.w * quat.y;
    let qwz = quat.w * quat.z;
    let qxy = quat.x * quat.y;
    let qyz = quat.y * quat.z;
    let qxz = quat.z * quat.x;
    let r00 = 1.0 - 2.0 * (qy2 + qz2);
    let r10 = 2.0 * (qxy + qwz);
    let r20 = 2.0 * (qxz - qwy);
    let r01 = 2.0 * (qxy - qwz);
    let r11 = 1.0 - 2.0 * (qx2 + qz2);
    let r21 = 2.0 * (qyz + qwx);
    let r02 = 2.0 * (qxz + qwy);
    let r12 = 2.0 * (qyz - qwx);
    let r22 = 1.0 - 2.0 * (qx2 + qy2);
    let pitch = 0;
    let yaw = 0;
    let roll = 0;
    const ONE_MINUS_EPSILON = 0.9999999;
    switch (order) {
        case OrientationEuler3DOrder.PitchYawRoll:
            {
                yaw = Math.asin(HiFiUtilities.clampNormalized(r02));
                if (Math.abs(r02) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r22);
                    roll = Math.atan2(-r01, r00);
                }
                else {
                    pitch = Math.atan2(r21, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawPitchRoll:
            {
                pitch = Math.asin(HiFiUtilities.clampNormalized(-r12));
                if (Math.abs(r12) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(r02, r22);
                    roll = Math.atan2(r10, r11);
                }
                else {
                    yaw = Math.atan2(-r20, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollPitchYaw:
            {
                pitch = Math.asin(HiFiUtilities.clampNormalized(r21));
                if (Math.abs(r21) < ONE_MINUS_EPSILON) {
                    yaw = Math.atan2(-r20, r22);
                    roll = Math.atan2(-r01, r11);
                }
                else {
                    roll = Math.atan2(r10, r00);
                }
            }
            break;
        case OrientationEuler3DOrder.RollYawPitch:
            {
                yaw = Math.asin(HiFiUtilities.clampNormalized(-r20));
                if (Math.abs(r20) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r22);
                    roll = Math.atan2(r10, r00);
                }
                else {
                    roll = Math.atan2(-r01, r11);
                }
            }
            break;
        case OrientationEuler3DOrder.YawRollPitch:
            {
                roll = Math.asin(HiFiUtilities.clampNormalized(r10));
                if (Math.abs(r10) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(-r12, r11);
                    yaw = Math.atan2(-r20, r00);
                }
                else {
                    yaw = Math.atan2(r02, r22);
                }
            }
            break;
        case OrientationEuler3DOrder.PitchRollYaw:
            {
                roll = Math.asin(HiFiUtilities.clampNormalized(-r01));
                if (Math.abs(r01) < ONE_MINUS_EPSILON) {
                    pitch = Math.atan2(r21, r11);
                    yaw = Math.atan2(r02, r00);
                }
                else {
                    yaw = Math.atan2(-r12, r22);
                }
            }
            break;
    }
    const RAD_TO_DEG = 180.0 / Math.PI;
    return new OrientationEuler3D({ pitchDegrees: RAD_TO_DEG * pitch, yawDegrees: RAD_TO_DEG * yaw, rollDegrees: RAD_TO_DEG * roll });
}
export class HiFiAudioAPIData {
    constructor({ position = null, orientationQuat = null, orientationEuler = null, volumeThreshold = null, hiFiGain = null, userAttenuation = null, userRolloff = null } = {}) {
        this.position = position;
        this.orientationQuat = orientationQuat;
        this.orientationEuler = orientationEuler;
        this.volumeThreshold = volumeThreshold;
        this.hiFiGain = hiFiGain;
        this.userAttenuation = userAttenuation;
        this.userRolloff = userRolloff;
        this._otherUserGainQueue = {};
    }
}
export class ReceivedHiFiAudioAPIData extends HiFiAudioAPIData {
    constructor(params = {}) {
        super(params);
        this.providedUserID = params.providedUserID;
        this.hashedVisitID = params.hashedVisitID;
        this.volumeDecibels = params.volumeDecibels;
        this.isStereo = params.isStereo;
    }
}
//# sourceMappingURL=HiFiAudioAPIData.js.map