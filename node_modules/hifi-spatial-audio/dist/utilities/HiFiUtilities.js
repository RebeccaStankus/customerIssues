import { HiFiLogger } from "./HiFiLogger";
function dynamicRequire(mod, requireString) {
    return mod.require(requireString);
}
let now;
if (typeof self === 'undefined') {
    try {
        now = dynamicRequire(module, 'perf_hooks').performance.now;
    }
    catch (_a) { }
}
export class HiFiUtilities {
    constructor() { }
    static recursivelyDiffObjects(obj1, obj2) {
        if (!obj2 || Object.prototype.toString.call(obj2) !== '[object Object]') {
            return obj1;
        }
        let diffs = {};
        let key;
        let doArraysMatch = (arr1, arr2) => {
            if (arr1.length !== arr2.length) {
                return false;
            }
            for (let i = 0; i < arr1.length; i++) {
                if (arr1[i] !== arr2[i]) {
                    return false;
                }
            }
            return true;
        };
        let compare = (item1, item2, key) => {
            let type1 = Object.prototype.toString.call(item1);
            let type2 = Object.prototype.toString.call(item2);
            if (type2 === '[object Undefined]') {
                diffs[key] = null;
                return;
            }
            if (type1 !== type2) {
                diffs[key] = item2;
                return;
            }
            if (type1 === '[object Object]') {
                let objDiff = HiFiUtilities.recursivelyDiffObjects(item1, item2);
                if (Object.keys(objDiff).length > 0) {
                    diffs[key] = objDiff;
                }
                return;
            }
            if (type1 === '[object Array]') {
                if (!doArraysMatch(item1, item2)) {
                    diffs[key] = item2;
                }
                return;
            }
            if (type1 === '[object Function]') {
                if (item1.toString() !== item2.toString()) {
                    diffs[key] = item2;
                }
            }
            else {
                if (item1 !== item2) {
                    diffs[key] = item2;
                }
            }
        };
        for (key in obj1) {
            if (obj1.hasOwnProperty(key)) {
                compare(obj1[key], obj2[key], key);
            }
        }
        for (key in obj2) {
            if (obj2.hasOwnProperty(key)) {
                if (!obj1[key] && obj1[key] !== obj2[key]) {
                    diffs[key] = obj2[key];
                }
            }
        }
        return diffs;
    }
    ;
    static getBestAudioConstraints() {
        let audioConstraints = {};
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().echoCancellation) {
            audioConstraints.echoCancellation = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().noiseSuppression) {
            audioConstraints.noiseSuppression = false;
        }
        if (typeof (navigator) !== "undefined" && typeof (navigator.mediaDevices) !== "undefined" && typeof (navigator.mediaDevices.getSupportedConstraints) !== "undefined" && navigator.mediaDevices.getSupportedConstraints().autoGainControl) {
            audioConstraints.autoGainControl = false;
        }
        return audioConstraints;
    }
    static preciseInterval(callback, intervalMS) {
        if (!now) {
            HiFiLogger.warn(`\`preciseInterval()\` is a wrapper for \`setInterval()\` in the browser context!`);
            return setInterval(callback, intervalMS);
        }
        let nextTick = now();
        let clear = clearTimeout;
        let wrapper = () => {
            let thisTick = now();
            if (thisTick < nextTick) {
                clear = clearImmediate;
                return timeout = setImmediate(wrapper);
            }
            nextTick += intervalMS;
            clear = clearTimeout;
            timeout = setTimeout(wrapper, nextTick - thisTick - 2);
            callback();
        };
        let timeout = setTimeout(wrapper);
        return { clear: () => clear(timeout) };
    }
    static checkBrowserCompatibility() {
        let requiredFeatures = [
            "navigator",
            "navigator.mediaDevices.getUserMedia",
            "navigator.mediaDevices.getSupportedConstraints",
            "window.MediaStream",
            "window.RTCDataChannel",
            "window.RTCPeerConnection",
            "window.RTCSessionDescription"
        ];
        for (let i = 0; i < requiredFeatures.length; i++) {
            if (typeof (eval(requiredFeatures[i])) === "undefined") {
                HiFiLogger.error("HiFi Audio API: The browser does not support: " + requiredFeatures[i]);
                if (requiredFeatures[i] === "navigator.mediaDevices.getUserMedia") {
                    HiFiLogger.error("HiFi Audio API: Your browser may be preventing access to this feature if you are running in an insecure context, i.e. an `http` server.");
                }
                return false;
            }
        }
        return true;
    }
    static nonan(v, ifnan) {
        return (isNaN(v) ? ifnan : v);
    }
    static clamp(v, min, max) {
        return (v > max ? max : (v < min ? min : v));
    }
    static clampNonan(v, min, max, ifnan) {
        return (v > max ? max : (v < min ? min : HiFiUtilities.nonan(v, ifnan)));
    }
    static clampNormalized(v) {
        return (v > 1.0 ? 1.0 : (v < -1.0 ? -1.0 : v));
    }
}
//# sourceMappingURL=HiFiUtilities.js.map